{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup with NextJS, TailwindCSS, and ShadUI",
        "description": "Initialize the project repository with NextJS App Directory structure, configure TailwindCSS, and integrate ShadUI component library.",
        "details": "1. Create a new NextJS project using the App Router: `npx create-next-app@latest chatbot-app --typescript --eslint --tailwind --app`\n2. Install ShadUI: `npm install @shadcn/ui`\n3. Initialize ShadUI: `npx shadcn-ui@latest init`\n4. Configure tailwind.config.js with ShadUI's recommended settings\n5. Set up project structure following NextJS App Directory conventions:\n   - app/\n     - layout.tsx (Root layout)\n     - page.tsx (Home page)\n     - chat/\n       - page.tsx (Chat interface)\n     - components/\n     - lib/\n     - styles/\n6. Configure environment variables in .env.local\n7. Set up ESLint and Prettier for code quality\n8. Initialize Git repository with appropriate .gitignore",
        "testStrategy": "1. Verify NextJS dev server starts without errors: `npm run dev`\n2. Confirm TailwindCSS styles are applied correctly\n3. Test ShadUI component rendering\n4. Ensure project structure follows App Directory conventions\n5. Validate environment variable loading",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase Local Setup and Database Schema",
        "description": "Set up a local Supabase instance and create the database schema for storing chat sessions and messages.",
        "details": "1. Install Supabase CLI: `npm install -g supabase`\n2. Initialize local Supabase: `supabase init`\n3. Start local Supabase: `supabase start`\n4. Create database schema with the following tables:\n   - chat_sessions:\n     ```sql\n     CREATE TABLE chat_sessions (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       title TEXT NOT NULL\n     );\n     ```\n   - chat_messages:\n     ```sql\n     CREATE TABLE chat_messages (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       chat_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE,\n       role TEXT CHECK (role IN ('user', 'assistant')),\n       content TEXT NOT NULL,\n       type TEXT CHECK (type IN ('text', 'image')),\n       image_url TEXT\n     );\n     ```\n5. Create migration files using: `supabase migration new initial_schema`\n6. Apply migrations: `supabase db reset`\n7. Install Supabase JS client: `npm install @supabase/supabase-js`\n8. Create lib/supabase.ts for client initialization:\n   ```typescript\n   import { createClient } from '@supabase/supabase-js';\n   \n   const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n   const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n   \n   export const supabase = createClient(supabaseUrl, supabaseAnonKey);\n   ```",
        "testStrategy": "1. Verify Supabase local instance is running: `supabase status`\n2. Test database connection using Supabase Studio\n3. Validate schema by inserting and querying test records\n4. Confirm foreign key constraints work correctly\n5. Test Supabase JS client connection from the application",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Basic UI Layout and Components",
        "description": "Create the core UI components for the chat interface including message display, input area, and navigation elements.",
        "details": "1. Create reusable UI components using ShadUI:\n   - components/ui/button.tsx\n   - components/ui/input.tsx\n   - components/ui/toggle.tsx\n   - components/ui/card.tsx\n2. Implement chat-specific components:\n   - components/chat/chat-container.tsx (Main chat area)\n   - components/chat/message-list.tsx (Displays conversation)\n   - components/chat/message-item.tsx (Individual message)\n   - components/chat/chat-input.tsx (User input area)\n   - components/chat/mode-toggle.tsx (Text/Image toggle)\n   - components/chat/new-chat-button.tsx\n3. Create layout components:\n   - components/layout/header.tsx\n   - components/layout/sidebar.tsx (for future chat history)\n4. Implement responsive design using TailwindCSS:\n   ```tsx\n   // Example message-item.tsx\n   import { cn } from '@/lib/utils';\n   \n   interface MessageProps {\n     role: 'user' | 'assistant';\n     content: string;\n     type: 'text' | 'image';\n     imageUrl?: string;\n   }\n   \n   export function MessageItem({ role, content, type, imageUrl }: MessageProps) {\n     return (\n       <div className={cn(\n         'flex w-full items-start gap-4 p-4',\n         role === 'user' ? 'bg-muted/50' : 'bg-background'\n       )}>\n         <div className=\"flex-1 space-y-2\">\n           <div className=\"font-semibold\">{role === 'user' ? 'You' : 'AI'}</div>\n           {type === 'text' ? (\n             <div className=\"text-sm\">{content}</div>\n           ) : (\n             <img src={imageUrl} alt={content} className=\"max-w-full rounded-md\" />\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Render each component in isolation to verify appearance\n2. Test responsive behavior using browser dev tools\n3. Verify component composition in different layouts\n4. Check accessibility using keyboard navigation and screen readers\n5. Test component props and state changes",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "OpenAI API Integration for Text Chat",
        "description": "Implement the integration with OpenAI's GPT-4.1-nano model for text-based chat functionality.",
        "details": "1. Install OpenAI SDK: `npm install openai`\n2. Create lib/openai.ts for API client setup:\n   ```typescript\n   import OpenAI from 'openai';\n   \n   export const openai = new OpenAI({\n     apiKey: process.env.OPENAI_API_KEY,\n   });\n   ```\n3. Create app/api/chat/route.ts for the chat endpoint:\n   ```typescript\n   import { openai } from '@/lib/openai';\n   import { NextRequest, NextResponse } from 'next/server';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages } = await req.json();\n       \n       const response = await openai.chat.completions.create({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages,\n         temperature: 0.7,\n       });\n       \n       return NextResponse.json(response.choices[0].message);\n     } catch (error) {\n       console.error('OpenAI API error:', error);\n       return NextResponse.json(\n         { error: 'An error occurred during your request.' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n4. Create lib/chat.ts for chat utility functions:\n   ```typescript\n   import { supabase } from './supabase';\n   \n   export type Message = {\n     role: 'user' | 'assistant';\n     content: string;\n     type: 'text' | 'image';\n     imageUrl?: string;\n   };\n   \n   export async function saveMessage(chatId: string, message: Message) {\n     return supabase.from('chat_messages').insert({\n       chat_id: chatId,\n       role: message.role,\n       content: message.content,\n       type: message.type,\n       image_url: message.imageUrl\n     });\n   }\n   \n   export async function createChatSession(title: string) {\n     const { data, error } = await supabase\n       .from('chat_sessions')\n       .insert({ title })\n       .select();\n     \n     if (error) throw error;\n     return data[0];\n   }\n   ```",
        "testStrategy": "1. Test OpenAI API connection with sample requests\n2. Verify error handling for API failures\n3. Test message formatting and parsing\n4. Validate API key configuration\n5. Test integration with chat interface components\n6. Verify database storage of messages",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Text Streaming Functionality",
        "description": "Implement real-time streaming of AI responses using OpenAI's streaming API with NextJS server components.",
        "details": "1. Create a streaming API endpoint in app/api/chat/streaming/route.ts:\n   ```typescript\n   import { openai } from '@/lib/openai';\n   import { NextRequest } from 'next/server';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages, chatId } = await req.json();\n       \n       const stream = await openai.chat.completions.create({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages,\n         temperature: 0.7,\n         stream: true,\n       });\n       \n       // Create a text encoder for the stream\n       const encoder = new TextEncoder();\n       \n       // Create and return a readable stream\n       const readableStream = new ReadableStream({\n         async start(controller) {\n           // Iterate through the stream\n           for await (const chunk of stream) {\n             const content = chunk.choices[0]?.delta?.content || '';\n             controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content })}\n\n`));\n           }\n           controller.enqueue(encoder.encode('data: [DONE]\n\n'));\n           controller.close();\n         },\n       });\n       \n       return new Response(readableStream, {\n         headers: {\n           'Content-Type': 'text/event-stream',\n           'Cache-Control': 'no-cache',\n           'Connection': 'keep-alive',\n         },\n       });\n     } catch (error) {\n       console.error('Streaming error:', error);\n       return new Response(JSON.stringify({ error: 'An error occurred' }), {\n         status: 500,\n         headers: { 'Content-Type': 'application/json' },\n       });\n     }\n   }\n   ```\n2. Create a React hook for consuming the stream in lib/hooks/useChat.ts:\n   ```typescript\n   import { useState, useCallback } from 'react';\n   import { Message } from '@/lib/chat';\n   \n   export function useChat() {\n     const [messages, setMessages] = useState<Message[]>([]);\n     const [isLoading, setIsLoading] = useState(false);\n     const [error, setError] = useState<string | null>(null);\n     const [chatId, setChatId] = useState<string | null>(null);\n     \n     const sendMessage = useCallback(async (content: string, type: 'text' | 'image' = 'text') => {\n       try {\n         setIsLoading(true);\n         setError(null);\n         \n         // Add user message to state\n         const userMessage: Message = { role: 'user', content, type };\n         setMessages(prev => [...prev, userMessage]);\n         \n         // Initialize assistant message with empty content\n         const assistantMessage: Message = { role: 'assistant', content: '', type: 'text' };\n         setMessages(prev => [...prev, assistantMessage]);\n         \n         // Prepare messages for API\n         const apiMessages = messages.concat(userMessage).map(msg => ({\n           role: msg.role,\n           content: msg.content\n         }));\n         \n         // Start streaming request\n         const response = await fetch('/api/chat/streaming', {\n           method: 'POST',\n           headers: { 'Content-Type': 'application/json' },\n           body: JSON.stringify({ messages: apiMessages, chatId }),\n         });\n         \n         if (!response.ok) throw new Error('Failed to send message');\n         \n         const reader = response.body?.getReader();\n         if (!reader) throw new Error('Failed to read stream');\n         \n         // Read stream\n         let accumulatedContent = '';\n         while (true) {\n           const { done, value } = await reader.read();\n           if (done) break;\n           \n           // Decode chunk\n           const chunk = new TextDecoder().decode(value);\n           const lines = chunk.split('\\n\\n').filter(line => line.startsWith('data: '));\n           \n           for (const line of lines) {\n             const data = line.replace('data: ', '');\n             if (data === '[DONE]') break;\n             \n             try {\n               const { content } = JSON.parse(data);\n               accumulatedContent += content;\n               \n               // Update assistant message with accumulated content\n               setMessages(prev => {\n                 const updated = [...prev];\n                 updated[updated.length - 1] = {\n                   ...updated[updated.length - 1],\n                   content: accumulatedContent\n                 };\n                 return updated;\n               });\n             } catch (e) {\n               console.error('Error parsing chunk:', e);\n             }\n           }\n         }\n         \n         // Save messages to database\n         if (chatId) {\n           // Save user message\n           await fetch('/api/messages', {\n             method: 'POST',\n             headers: { 'Content-Type': 'application/json' },\n             body: JSON.stringify({ chatId, message: userMessage }),\n           });\n           \n           // Save assistant message\n           await fetch('/api/messages', {\n             method: 'POST',\n             headers: { 'Content-Type': 'application/json' },\n             body: JSON.stringify({\n               chatId,\n               message: {\n                 role: 'assistant',\n                 content: accumulatedContent,\n                 type: 'text'\n               }\n             }),\n           });\n         }\n       } catch (e) {\n         setError(e instanceof Error ? e.message : 'An unknown error occurred');\n         console.error('Chat error:', e);\n       } finally {\n         setIsLoading(false);\n       }\n     }, [messages, chatId]);\n     \n     return { messages, isLoading, error, sendMessage, chatId, setChatId };\n   }\n   ```",
        "testStrategy": "1. Test streaming API endpoint with Postman or similar tool\n2. Verify real-time token rendering in the UI\n3. Test error handling during stream interruptions\n4. Measure streaming performance and latency\n5. Verify message accumulation and state updates\n6. Test database storage of complete messages after streaming",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Chat Interface with Message Display",
        "description": "Create the main chat interface that displays the conversation history and handles user input for text chat.",
        "details": "1. Create the chat page in app/chat/page.tsx:\n   ```tsx\n   'use client';\n   \n   import { useState, useRef, useEffect } from 'react';\n   import { useChat } from '@/lib/hooks/useChat';\n   import { Button } from '@/components/ui/button';\n   import { Input } from '@/components/ui/input';\n   import { MessageItem } from '@/components/chat/message-item';\n   import { ModeToggle } from '@/components/chat/mode-toggle';\n   import { NewChatButton } from '@/components/chat/new-chat-button';\n   \n   export default function ChatPage() {\n     const { messages, isLoading, error, sendMessage, chatId, setChatId } = useChat();\n     const [input, setInput] = useState('');\n     const [mode, setMode] = useState<'text' | 'image'>('text');\n     const messagesEndRef = useRef<HTMLDivElement>(null);\n     \n     // Scroll to bottom when messages change\n     useEffect(() => {\n       messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n     }, [messages]);\n     \n     // Handle form submission\n     const handleSubmit = (e: React.FormEvent) => {\n       e.preventDefault();\n       if (!input.trim() || isLoading) return;\n       \n       sendMessage(input, mode);\n       setInput('');\n     };\n     \n     // Start new chat\n     const handleNewChat = () => {\n       setChatId(null);\n     };\n     \n     return (\n       <div className=\"flex flex-col h-screen max-h-screen\">\n         <header className=\"border-b p-4 flex justify-between items-center\">\n           <h1 className=\"text-xl font-bold\">AI Chat</h1>\n           <div className=\"flex items-center gap-2\">\n             <ModeToggle mode={mode} onChange={setMode} />\n             <NewChatButton onClick={handleNewChat} />\n           </div>\n         </header>\n         \n         <main className=\"flex-1 overflow-auto p-4\">\n           <div className=\"max-w-3xl mx-auto space-y-4\">\n             {messages.length === 0 ? (\n               <div className=\"text-center text-muted-foreground py-12\">\n                 Start a conversation or generate an image\n               </div>\n             ) : (\n               messages.map((message, i) => (\n                 <MessageItem key={i} {...message} />\n               ))\n             )}\n             <div ref={messagesEndRef} />\n           </div>\n         </main>\n         \n         <footer className=\"border-t p-4\">\n           <form onSubmit={handleSubmit} className=\"max-w-3xl mx-auto flex gap-2\">\n             <Input\n               value={input}\n               onChange={(e) => setInput(e.target.value)}\n               placeholder={mode === 'text' ? 'Type a message...' : 'Describe the image you want...'}\n               disabled={isLoading}\n               className=\"flex-1\"\n             />\n             <Button type=\"submit\" disabled={isLoading}>\n               {isLoading ? 'Sending...' : 'Send'}\n             </Button>\n           </form>\n           {error && (\n             <p className=\"text-red-500 text-sm mt-2 max-w-3xl mx-auto\">{error}</p>\n           )}\n         </footer>\n       </div>\n     );\n   }\n   ```\n2. Create the ModeToggle component in components/chat/mode-toggle.tsx:\n   ```tsx\n   import { Button } from '@/components/ui/button';\n   import { MessageSquare, Image } from 'lucide-react';\n   \n   interface ModeToggleProps {\n     mode: 'text' | 'image';\n     onChange: (mode: 'text' | 'image') => void;\n   }\n   \n   export function ModeToggle({ mode, onChange }: ModeToggleProps) {\n     return (\n       <div className=\"flex border rounded-md overflow-hidden\">\n         <Button\n           variant={mode === 'text' ? 'default' : 'ghost'}\n           size=\"sm\"\n           onClick={() => onChange('text')}\n           className=\"rounded-none\"\n         >\n           <MessageSquare className=\"h-4 w-4 mr-2\" />\n           Text\n         </Button>\n         <Button\n           variant={mode === 'image' ? 'default' : 'ghost'}\n           size=\"sm\"\n           onClick={() => onChange('image')}\n           className=\"rounded-none\"\n         >\n           <Image className=\"h-4 w-4 mr-2\" />\n           Image\n         </Button>\n       </div>\n     );\n   }\n   ```\n3. Create the NewChatButton component in components/chat/new-chat-button.tsx:\n   ```tsx\n   import { Button } from '@/components/ui/button';\n   import { Plus } from 'lucide-react';\n   \n   interface NewChatButtonProps {\n     onClick: () => void;\n   }\n   \n   export function NewChatButton({ onClick }: NewChatButtonProps) {\n     return (\n       <Button variant=\"outline\" size=\"sm\" onClick={onClick}>\n         <Plus className=\"h-4 w-4 mr-2\" />\n         New Chat\n       </Button>\n     );\n   }\n   ```",
        "testStrategy": "1. Test user input submission and validation\n2. Verify message display and formatting\n3. Test scrolling behavior with many messages\n4. Verify loading states and error messages\n5. Test mode toggle between text and image\n6. Test new chat functionality\n7. Verify responsive design on different screen sizes",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement OpenAI Image Generation",
        "description": "Integrate OpenAI's gpt-image-1 model for AI image generation functionality.",
        "details": "1. Create an image generation API endpoint in app/api/images/route.ts:\n   ```typescript\n   import { openai } from '@/lib/openai';\n   import { NextRequest, NextResponse } from 'next/server';\n   import { supabase } from '@/lib/supabase';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { prompt, chatId } = await req.json();\n       \n       // Generate image using OpenAI\n       const response = await openai.images.generate({\n         model: 'gpt-image-1',\n         prompt,\n         n: 1,\n         size: '1024x1024',\n         response_format: 'url',\n       });\n       \n       const imageUrl = response.data[0]?.url;\n       \n       if (!imageUrl) {\n         throw new Error('No image was generated');\n       }\n       \n       // If chatId is provided, save messages to database\n       if (chatId) {\n         // Save user prompt\n         await supabase.from('chat_messages').insert({\n           chat_id: chatId,\n           role: 'user',\n           content: prompt,\n           type: 'text'\n         });\n         \n         // Save assistant response with image\n         await supabase.from('chat_messages').insert({\n           chat_id: chatId,\n           role: 'assistant',\n           content: 'Generated image based on your prompt',\n           type: 'image',\n           image_url: imageUrl\n         });\n       }\n       \n       return NextResponse.json({ imageUrl });\n     } catch (error) {\n       console.error('Image generation error:', error);\n       return NextResponse.json(\n         { error: 'Failed to generate image' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n2. Update the useChat hook in lib/hooks/useChat.ts to handle image generation:\n   ```typescript\n   // Add to existing useChat hook\n   const generateImage = useCallback(async (prompt: string) => {\n     try {\n       setIsLoading(true);\n       setError(null);\n       \n       // Add user message to state\n       const userMessage = { role: 'user', content: prompt, type: 'text' as const };\n       setMessages(prev => [...prev, userMessage]);\n       \n       // Call image generation API\n       const response = await fetch('/api/images', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({ prompt, chatId }),\n       });\n       \n       if (!response.ok) {\n         const errorData = await response.json();\n         throw new Error(errorData.error || 'Failed to generate image');\n       }\n       \n       const { imageUrl } = await response.json();\n       \n       // Add assistant message with image\n       const assistantMessage = {\n         role: 'assistant' as const,\n         content: 'Generated image based on your prompt',\n         type: 'image' as const,\n         imageUrl\n       };\n       \n       setMessages(prev => [...prev, assistantMessage]);\n     } catch (e) {\n       setError(e instanceof Error ? e.message : 'An unknown error occurred');\n       console.error('Image generation error:', e);\n     } finally {\n       setIsLoading(false);\n     }\n   }, [chatId]);\n   \n   // Return generateImage in the hook\n   return { messages, isLoading, error, sendMessage, generateImage, chatId, setChatId };\n   ```\n3. Update the chat page to handle image generation:\n   ```tsx\n   // In app/chat/page.tsx, modify handleSubmit\n   const handleSubmit = (e: React.FormEvent) => {\n     e.preventDefault();\n     if (!input.trim() || isLoading) return;\n     \n     if (mode === 'text') {\n       sendMessage(input);\n     } else {\n       generateImage(input);\n     }\n     \n     setInput('');\n   };\n   ```",
        "testStrategy": "1. Test image generation with various prompts\n2. Verify image display in the chat interface\n3. Test error handling for failed image generation\n4. Verify database storage of image URLs\n5. Test mode switching between text and image\n6. Measure performance and loading times for image generation",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement New Chat Functionality",
        "description": "Create functionality to start a new chat session while storing the previous conversation in Supabase.",
        "details": "1. Create an API endpoint for creating new chat sessions in app/api/chats/route.ts:\n   ```typescript\n   import { NextRequest, NextResponse } from 'next/server';\n   import { supabase } from '@/lib/supabase';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { title } = await req.json();\n       \n       const { data, error } = await supabase\n         .from('chat_sessions')\n         .insert({ title: title || 'New Chat' })\n         .select();\n       \n       if (error) throw error;\n       \n       return NextResponse.json({ chatId: data[0].id });\n     } catch (error) {\n       console.error('Failed to create chat session:', error);\n       return NextResponse.json(\n         { error: 'Failed to create chat session' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n2. Update the useChat hook to handle new chat creation:\n   ```typescript\n   // Add to existing useChat hook\n   const createNewChat = useCallback(async (firstMessage?: string) => {\n     try {\n       // Clear current messages\n       setMessages([]);\n       \n       // Create new chat session\n       const title = firstMessage?.substring(0, 50) || 'New Chat';\n       const response = await fetch('/api/chats', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({ title }),\n       });\n       \n       if (!response.ok) {\n         const errorData = await response.json();\n         throw new Error(errorData.error || 'Failed to create new chat');\n       }\n       \n       const { chatId: newChatId } = await response.json();\n       setChatId(newChatId);\n       \n       return newChatId;\n     } catch (e) {\n       setError(e instanceof Error ? e.message : 'Failed to create new chat');\n       console.error('New chat error:', e);\n       return null;\n     }\n   }, []);\n   \n   // Return createNewChat in the hook\n   return { messages, isLoading, error, sendMessage, generateImage, chatId, setChatId, createNewChat };\n   ```\n3. Update the NewChatButton component to use the createNewChat function:\n   ```tsx\n   // In app/chat/page.tsx\n   const { messages, isLoading, error, sendMessage, generateImage, chatId, setChatId, createNewChat } = useChat();\n   \n   // Update handleNewChat\n   const handleNewChat = async () => {\n     await createNewChat();\n   };\n   ```\n4. Create an API endpoint to fetch chat history in app/api/chats/[id]/route.ts:\n   ```typescript\n   import { NextRequest, NextResponse } from 'next/server';\n   import { supabase } from '@/lib/supabase';\n   \n   export async function GET(req: NextRequest, { params }: { params: { id: string } }) {\n     try {\n       const chatId = params.id;\n       \n       // Fetch chat messages\n       const { data: messages, error: messagesError } = await supabase\n         .from('chat_messages')\n         .select('*')\n         .eq('chat_id', chatId)\n         .order('created_at', { ascending: true });\n       \n       if (messagesError) throw messagesError;\n       \n       // Fetch chat session\n       const { data: session, error: sessionError } = await supabase\n         .from('chat_sessions')\n         .select('*')\n         .eq('id', chatId)\n         .single();\n       \n       if (sessionError) throw sessionError;\n       \n       return NextResponse.json({ session, messages });\n     } catch (error) {\n       console.error('Failed to fetch chat:', error);\n       return NextResponse.json(\n         { error: 'Failed to fetch chat' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n5. Add a function to load chat history in the useChat hook:\n   ```typescript\n   // Add to existing useChat hook\n   const loadChat = useCallback(async (id: string) => {\n     try {\n       setIsLoading(true);\n       \n       const response = await fetch(`/api/chats/${id}`);\n       \n       if (!response.ok) {\n         const errorData = await response.json();\n         throw new Error(errorData.error || 'Failed to load chat');\n       }\n       \n       const { messages: chatMessages } = await response.json();\n       \n       // Transform database messages to app format\n       const formattedMessages = chatMessages.map((msg: any) => ({\n         role: msg.role as 'user' | 'assistant',\n         content: msg.content,\n         type: msg.type as 'text' | 'image',\n         imageUrl: msg.image_url\n       }));\n       \n       setMessages(formattedMessages);\n       setChatId(id);\n     } catch (e) {\n       setError(e instanceof Error ? e.message : 'Failed to load chat');\n       console.error('Load chat error:', e);\n     } finally {\n       setIsLoading(false);\n     }\n   }, []);\n   \n   // Return loadChat in the hook\n   return { messages, isLoading, error, sendMessage, generateImage, chatId, setChatId, createNewChat, loadChat };\n   ```",
        "testStrategy": "1. Test creating a new chat session\n2. Verify previous chat is stored in database\n3. Test loading existing chat history\n4. Verify chat title generation from first message\n5. Test error handling for failed chat creation or loading\n6. Verify UI state updates when switching between chats",
        "priority": "medium",
        "dependencies": [
          2,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Chat History Sidebar",
        "description": "Create a sidebar that displays previous chat sessions and allows users to switch between them.",
        "details": "1. Create an API endpoint to fetch all chat sessions in app/api/chats/route.ts:\n   ```typescript\n   // Add GET method to existing file\n   export async function GET() {\n     try {\n       const { data, error } = await supabase\n         .from('chat_sessions')\n         .select('*')\n         .order('updated_at', { ascending: false });\n       \n       if (error) throw error;\n       \n       return NextResponse.json({ chats: data });\n     } catch (error) {\n       console.error('Failed to fetch chats:', error);\n       return NextResponse.json(\n         { error: 'Failed to fetch chats' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n2. Create a hook for managing chat history in lib/hooks/useChatHistory.ts:\n   ```typescript\n   import { useState, useEffect, useCallback } from 'react';\n   \n   type ChatSession = {\n     id: string;\n     title: string;\n     created_at: string;\n     updated_at: string;\n   };\n   \n   export function useChatHistory() {\n     const [chats, setChats] = useState<ChatSession[]>([]);\n     const [isLoading, setIsLoading] = useState(false);\n     const [error, setError] = useState<string | null>(null);\n     \n     const fetchChats = useCallback(async () => {\n       try {\n         setIsLoading(true);\n         setError(null);\n         \n         const response = await fetch('/api/chats');\n         \n         if (!response.ok) {\n           const errorData = await response.json();\n           throw new Error(errorData.error || 'Failed to fetch chats');\n         }\n         \n         const { chats: chatData } = await response.json();\n         setChats(chatData);\n       } catch (e) {\n         setError(e instanceof Error ? e.message : 'An unknown error occurred');\n         console.error('Fetch chats error:', e);\n       } finally {\n         setIsLoading(false);\n       }\n     }, []);\n     \n     useEffect(() => {\n       fetchChats();\n     }, [fetchChats]);\n     \n     return { chats, isLoading, error, refreshChats: fetchChats };\n   }\n   ```\n3. Create a Sidebar component in components/layout/sidebar.tsx:\n   ```tsx\n   import { useChatHistory } from '@/lib/hooks/useChatHistory';\n   import { Button } from '@/components/ui/button';\n   import { Skeleton } from '@/components/ui/skeleton';\n   import { MessageSquare, Plus } from 'lucide-react';\n   import { formatDistanceToNow } from 'date-fns';\n   \n   interface SidebarProps {\n     currentChatId: string | null;\n     onChatSelect: (chatId: string) => void;\n     onNewChat: () => void;\n   }\n   \n   export function Sidebar({ currentChatId, onChatSelect, onNewChat }: SidebarProps) {\n     const { chats, isLoading, error } = useChatHistory();\n     \n     return (\n       <div className=\"w-64 border-r h-full flex flex-col\">\n         <div className=\"p-4 border-b\">\n           <Button onClick={onNewChat} className=\"w-full\">\n             <Plus className=\"h-4 w-4 mr-2\" />\n             New Chat\n           </Button>\n         </div>\n         \n         <div className=\"flex-1 overflow-auto p-2\">\n           {isLoading ? (\n             Array.from({ length: 5 }).map((_, i) => (\n               <div key={i} className=\"mb-2\">\n                 <Skeleton className=\"h-12 w-full\" />\n               </div>\n             ))\n           ) : error ? (\n             <p className=\"text-red-500 p-2 text-sm\">{error}</p>\n           ) : chats.length === 0 ? (\n             <p className=\"text-muted-foreground p-2 text-sm\">No chat history</p>\n           ) : (\n             chats.map((chat) => (\n               <Button\n                 key={chat.id}\n                 variant={currentChatId === chat.id ? 'secondary' : 'ghost'}\n                 className=\"w-full justify-start mb-1 overflow-hidden\"\n                 onClick={() => onChatSelect(chat.id)}\n               >\n                 <MessageSquare className=\"h-4 w-4 mr-2 flex-shrink-0\" />\n                 <div className=\"truncate text-left\">\n                   <div className=\"truncate\">{chat.title}</div>\n                   <div className=\"text-xs text-muted-foreground truncate\">\n                     {formatDistanceToNow(new Date(chat.updated_at), { addSuffix: true })}\n                   </div>\n                 </div>\n               </Button>\n             ))\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```\n4. Update the chat page layout to include the sidebar:\n   ```tsx\n   // In app/chat/page.tsx\n   import { Sidebar } from '@/components/layout/sidebar';\n   \n   export default function ChatPage() {\n     // Existing code...\n     \n     // Add handler for chat selection\n     const handleChatSelect = (selectedChatId: string) => {\n       loadChat(selectedChatId);\n     };\n     \n     return (\n       <div className=\"flex h-screen max-h-screen\">\n         <Sidebar\n           currentChatId={chatId}\n           onChatSelect={handleChatSelect}\n           onNewChat={handleNewChat}\n         />\n         \n         <div className=\"flex flex-col flex-1 h-full\">\n           {/* Existing header, main, and footer */}\n         </div>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test fetching and displaying chat history\n2. Verify chat selection functionality\n3. Test new chat creation from sidebar\n4. Verify current chat highlighting\n5. Test responsive behavior on different screen sizes\n6. Verify loading states and error handling",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Error Handling and Loading States",
        "description": "Enhance the application with comprehensive error handling and loading state indicators for a better user experience.",
        "details": "1. Create reusable loading components in components/ui/loading.tsx:\n   ```tsx\n   import { Loader2 } from 'lucide-react';\n   \n   export function LoadingSpinner({ className }: { className?: string }) {\n     return <Loader2 className={`animate-spin ${className || 'h-4 w-4'}`} />;\n   }\n   \n   export function LoadingDots() {\n     return (\n       <div className=\"flex space-x-1 items-center\">\n         <span className=\"h-2 w-2 bg-current rounded-full animate-bounce\" style={{ animationDelay: '0ms' }} />\n         <span className=\"h-2 w-2 bg-current rounded-full animate-bounce\" style={{ animationDelay: '150ms' }} />\n         <span className=\"h-2 w-2 bg-current rounded-full animate-bounce\" style={{ animationDelay: '300ms' }} />\n       </div>\n     );\n   }\n   \n   export function LoadingMessage() {\n     return (\n       <div className=\"flex items-center gap-2 text-muted-foreground\">\n         <LoadingDots />\n         <span>AI is thinking</span>\n       </div>\n     );\n   }\n   ```\n2. Create an error boundary component in components/error-boundary.tsx:\n   ```tsx\n   'use client';\n   \n   import { Component, ErrorInfo, ReactNode } from 'react';\n   import { Button } from '@/components/ui/button';\n   \n   interface Props {\n     children: ReactNode;\n     fallback?: ReactNode;\n   }\n   \n   interface State {\n     hasError: boolean;\n     error: Error | null;\n   }\n   \n   export class ErrorBoundary extends Component<Props, State> {\n     constructor(props: Props) {\n       super(props);\n       this.state = { hasError: false, error: null };\n     }\n   \n     static getDerivedStateFromError(error: Error): State {\n       return { hasError: true, error };\n     }\n   \n     componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n       console.error('Error caught by boundary:', error, errorInfo);\n     }\n   \n     render() {\n       if (this.state.hasError) {\n         if (this.props.fallback) {\n           return this.props.fallback;\n         }\n         \n         return (\n           <div className=\"p-6 max-w-md mx-auto my-8 border rounded-lg bg-muted/50\">\n             <h2 className=\"text-xl font-bold mb-4\">Something went wrong</h2>\n             <p className=\"text-muted-foreground mb-4\">\n               {this.state.error?.message || 'An unexpected error occurred'}\n             </p>\n             <Button onClick={() => window.location.reload()}>Refresh Page</Button>\n           </div>\n         );\n       }\n   \n       return this.props.children;\n     }\n   }\n   ```\n3. Create a toast notification system in components/ui/toast.tsx:\n   ```tsx\n   'use client';\n   \n   import { useState, useEffect } from 'react';\n   import { X } from 'lucide-react';\n   \n   type ToastProps = {\n     message: string;\n     type: 'success' | 'error' | 'info';\n     duration?: number;\n     onClose: () => void;\n   };\n   \n   export function Toast({ message, type, duration = 5000, onClose }: ToastProps) {\n     useEffect(() => {\n       const timer = setTimeout(() => {\n         onClose();\n       }, duration);\n       \n       return () => clearTimeout(timer);\n     }, [duration, onClose]);\n     \n     const bgColor = {\n       success: 'bg-green-100 border-green-500 text-green-800',\n       error: 'bg-red-100 border-red-500 text-red-800',\n       info: 'bg-blue-100 border-blue-500 text-blue-800'\n     }[type];\n     \n     return (\n       <div className={`p-4 rounded-md border-l-4 flex justify-between items-center ${bgColor}`}>\n         <p>{message}</p>\n         <button onClick={onClose} className=\"ml-4\">\n           <X className=\"h-4 w-4\" />\n         </button>\n       </div>\n     );\n   }\n   \n   type ToastContextType = {\n     showToast: (message: string, type: 'success' | 'error' | 'info') => void;\n   };\n   \n   export function ToastContainer() {\n     const [toasts, setToasts] = useState<Array<{ id: string; message: string; type: 'success' | 'error' | 'info' }>>([]);\n     \n     const showToast = (message: string, type: 'success' | 'error' | 'info') => {\n       const id = Math.random().toString(36).substring(2, 9);\n       setToasts((prev) => [...prev, { id, message, type }]);\n     };\n     \n     const removeToast = (id: string) => {\n       setToasts((prev) => prev.filter((toast) => toast.id !== id));\n     };\n     \n     return (\n       <>\n         <div className=\"fixed bottom-4 right-4 z-50 flex flex-col gap-2 max-w-md\">\n           {toasts.map((toast) => (\n             <Toast\n               key={toast.id}\n               message={toast.message}\n               type={toast.type}\n               onClose={() => removeToast(toast.id)}\n             />\n           ))}\n         </div>\n       </>\n     );\n   }\n   \n   // Create a custom hook for using toasts\n   export function useToast() {\n     const [toasts, setToasts] = useState<Array<{ id: string; message: string; type: 'success' | 'error' | 'info' }>>([]);\n     \n     const showToast = (message: string, type: 'success' | 'error' | 'info' = 'info') => {\n       const id = Math.random().toString(36).substring(2, 9);\n       setToasts((prev) => [...prev, { id, message, type }]);\n       \n       // Auto-remove after 5 seconds\n       setTimeout(() => {\n         setToasts((prev) => prev.filter((toast) => toast.id !== id));\n       }, 5000);\n     };\n     \n     const ToastContainer = () => (\n       <div className=\"fixed bottom-4 right-4 z-50 flex flex-col gap-2 max-w-md\">\n         {toasts.map((toast) => (\n           <Toast\n             key={toast.id}\n             message={toast.message}\n             type={toast.type}\n             onClose={() => setToasts((prev) => prev.filter((t) => t.id !== toast.id))}\n           />\n         ))}\n       </div>\n     );\n     \n     return { showToast, ToastContainer };\n   }\n   ```\n4. Update the chat page to use these components:\n   ```tsx\n   // In app/chat/page.tsx\n   import { ErrorBoundary } from '@/components/error-boundary';\n   import { LoadingMessage, LoadingSpinner } from '@/components/ui/loading';\n   import { useToast } from '@/components/ui/toast';\n   \n   export default function ChatPage() {\n     // Existing code...\n     const { showToast, ToastContainer } = useToast();\n     \n     // Update error handling\n     useEffect(() => {\n       if (error) {\n         showToast(error, 'error');\n       }\n     }, [error, showToast]);\n     \n     // Update the return JSX\n     return (\n       <ErrorBoundary>\n         <div className=\"flex h-screen max-h-screen\">\n           {/* Sidebar */}\n           \n           <div className=\"flex flex-col flex-1 h-full\">\n             {/* Header */}\n             \n             <main className=\"flex-1 overflow-auto p-4\">\n               <div className=\"max-w-3xl mx-auto space-y-4\">\n                 {messages.length === 0 ? (\n                   <div className=\"text-center text-muted-foreground py-12\">\n                     Start a conversation or generate an image\n                   </div>\n                 ) : (\n                   messages.map((message, i) => (\n                     <MessageItem key={i} {...message} />\n                   ))\n                 )}\n                 {isLoading && (\n                   <div className=\"p-4 rounded-md bg-muted/50\">\n                     <LoadingMessage />\n                   </div>\n                 )}\n                 <div ref={messagesEndRef} />\n               </div>\n             </main>\n             \n             <footer className=\"border-t p-4\">\n               <form onSubmit={handleSubmit} className=\"max-w-3xl mx-auto flex gap-2\">\n                 <Input\n                   value={input}\n                   onChange={(e) => setInput(e.target.value)}\n                   placeholder={mode === 'text' ? 'Type a message...' : 'Describe the image you want...'}\n                   disabled={isLoading}\n                   className=\"flex-1\"\n                 />\n                 <Button type=\"submit\" disabled={isLoading}>\n                   {isLoading ? <LoadingSpinner className=\"mr-2\" /> : null}\n                   {isLoading ? 'Sending...' : 'Send'}\n                 </Button>\n               </form>\n             </footer>\n           </div>\n         </div>\n         <ToastContainer />\n       </ErrorBoundary>\n     );\n   }\n   ```",
        "testStrategy": "1. Test error handling for API failures\n2. Verify loading indicators appear at appropriate times\n3. Test error boundary by intentionally causing errors\n4. Verify toast notifications for different error types\n5. Test loading states during streaming responses\n6. Verify error recovery mechanisms",
        "priority": "medium",
        "dependencies": [
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Responsive Design and Cross-Browser Compatibility",
        "description": "Enhance the application with responsive design for various screen sizes and ensure cross-browser compatibility.",
        "details": "1. Create responsive utility components in components/ui/responsive.tsx:\n   ```tsx\n   'use client';\n   \n   import { useState, useEffect } from 'react';\n   import { Menu, X } from 'lucide-react';\n   import { Button } from '@/components/ui/button';\n   \n   interface MobileSidebarToggleProps {\n     onToggle: () => void;\n     isOpen: boolean;\n   }\n   \n   export function MobileSidebarToggle({ onToggle, isOpen }: MobileSidebarToggleProps) {\n     return (\n       <Button variant=\"ghost\" size=\"icon\" onClick={onToggle} className=\"md:hidden\">\n         {isOpen ? <X className=\"h-5 w-5\" /> : <Menu className=\"h-5 w-5\" />}\n       </Button>\n     );\n   }\n   \n   export function useMediaQuery(query: string): boolean {\n     const [matches, setMatches] = useState(false);\n     \n     useEffect(() => {\n       const media = window.matchMedia(query);\n       if (media.matches !== matches) {\n         setMatches(media.matches);\n       }\n       \n       const listener = () => setMatches(media.matches);\n       media.addEventListener('change', listener);\n       \n       return () => media.removeEventListener('change', listener);\n     }, [matches, query]);\n     \n     return matches;\n   }\n   ```\n2. Update the Sidebar component to be responsive:\n   ```tsx\n   // In components/layout/sidebar.tsx\n   interface SidebarProps {\n     currentChatId: string | null;\n     onChatSelect: (chatId: string) => void;\n     onNewChat: () => void;\n     isOpen: boolean; // For mobile\n     className?: string;\n   }\n   \n   export function Sidebar({ currentChatId, onChatSelect, onNewChat, isOpen, className }: SidebarProps) {\n     // Existing code...\n     \n     return (\n       <div className={`border-r h-full flex flex-col ${isOpen ? 'block' : 'hidden'} md:block ${className || ''}`}>\n         {/* Existing content */}\n       </div>\n     );\n   }\n   ```\n3. Update the chat page layout for responsive design:\n   ```tsx\n   // In app/chat/page.tsx\n   import { MobileSidebarToggle, useMediaQuery } from '@/components/ui/responsive';\n   \n   export default function ChatPage() {\n     // Existing code...\n     const [sidebarOpen, setSidebarOpen] = useState(false);\n     const isMobile = !useMediaQuery('(min-width: 768px)');\n     \n     // Close sidebar when selecting a chat on mobile\n     const handleChatSelect = (selectedChatId: string) => {\n       loadChat(selectedChatId);\n       if (isMobile) {\n         setSidebarOpen(false);\n       }\n     };\n     \n     return (\n       <ErrorBoundary>\n         <div className=\"flex h-screen max-h-screen\">\n           {/* Mobile sidebar as overlay */}\n           {isMobile && sidebarOpen && (\n             <div \n               className=\"fixed inset-0 bg-black/50 z-40\" \n               onClick={() => setSidebarOpen(false)}\n             />\n           )}\n           \n           <Sidebar\n             currentChatId={chatId}\n             onChatSelect={handleChatSelect}\n             onNewChat={handleNewChat}\n             isOpen={sidebarOpen}\n             className={`${isMobile ? 'fixed z-50 bg-background w-64 h-full' : 'w-64'}`}\n           />\n           \n           <div className=\"flex flex-col flex-1 h-full\">\n             <header className=\"border-b p-4 flex justify-between items-center\">\n               <div className=\"flex items-center gap-2\">\n                 <MobileSidebarToggle \n                   isOpen={sidebarOpen} \n                   onToggle={() => setSidebarOpen(!sidebarOpen)} \n                 />\n                 <h1 className=\"text-xl font-bold\">AI Chat</h1>\n               </div>\n               <div className=\"flex items-center gap-2\">\n                 <ModeToggle mode={mode} onChange={setMode} />\n                 <NewChatButton onClick={handleNewChat} className=\"hidden sm:flex\" />\n               </div>\n             </header>\n             \n             {/* Existing main and footer */}\n           </div>\n         </div>\n         <ToastContainer />\n       </ErrorBoundary>\n     );\n   }\n   ```\n4. Add cross-browser compatibility fixes in app/globals.css:\n   ```css\n   /* Add to existing globals.css */\n   \n   /* Fix for iOS height issues */\n   html, body {\n     height: 100%;\n     overflow: hidden;\n   }\n   \n   /* Fix for Safari scrolling */\n   .safari-fix {\n     -webkit-overflow-scrolling: touch;\n   }\n   \n   /* Fix for Firefox focus rings */\n   :focus {\n     outline: none;\n   }\n   :focus-visible {\n     outline: 2px solid hsl(var(--primary));\n     outline-offset: 2px;\n   }\n   \n   /* Fix for Edge input rendering */\n   input, textarea {\n     -webkit-appearance: none;\n     appearance: none;\n   }\n   ```\n5. Add browser detection and specific fixes in app/layout.tsx:\n   ```tsx\n   // In app/layout.tsx\n   import { headers } from 'next/headers';\n   \n   export default function RootLayout({ children }: { children: React.ReactNode }) {\n     // Get user agent for browser detection\n     const headersList = headers();\n     const userAgent = headersList.get('user-agent') || '';\n     \n     // Add browser-specific classes\n     const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');\n     const isFirefox = userAgent.includes('Firefox');\n     const isEdge = userAgent.includes('Edg/');\n     \n     const browserClasses = [\n       isSafari && 'browser-safari',\n       isFirefox && 'browser-firefox',\n       isEdge && 'browser-edge',\n     ].filter(Boolean).join(' ');\n     \n     return (\n       <html lang=\"en\" className={browserClasses}>\n         <body className=\"min-h-screen bg-background\">\n           {children}\n         </body>\n       </html>\n     );\n   }\n   ```",
        "testStrategy": "1. Test responsive design on various screen sizes (mobile, tablet, desktop)\n2. Verify sidebar behavior on mobile devices\n3. Test touch interactions on mobile devices\n4. Verify rendering in different browsers (Chrome, Firefox, Safari, Edge)\n5. Test keyboard accessibility across browsers\n6. Verify scrolling behavior on different devices\n7. Test font rendering consistency across platforms",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Deployment Pipeline and Environment Configuration",
        "description": "Set up the deployment pipeline and environment configuration for production deployment.",
        "details": "1. Create a production-ready Supabase setup:\n   ```bash\n   # Create production migration script\n   supabase migration new production_setup\n   ```\n   \n   In the generated migration file:\n   ```sql\n   -- Enable Row Level Security\n   ALTER TABLE chat_sessions ENABLE ROW LEVEL SECURITY;\n   ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;\n   \n   -- Create policies\n   CREATE POLICY \"Public read access for chat_sessions\" ON chat_sessions FOR SELECT USING (true);\n   CREATE POLICY \"Public insert access for chat_sessions\" ON chat_sessions FOR INSERT WITH CHECK (true);\n   \n   CREATE POLICY \"Public read access for chat_messages\" ON chat_messages FOR SELECT USING (true);\n   CREATE POLICY \"Public insert access for chat_messages\" ON chat_messages FOR INSERT WITH CHECK (true);\n   \n   -- Create indexes for performance\n   CREATE INDEX idx_chat_messages_chat_id ON chat_messages(chat_id);\n   CREATE INDEX idx_chat_sessions_updated_at ON chat_sessions(updated_at DESC);\n   ```\n\n2. Create environment configuration files:\n   - .env.local (for development)\n   - .env.production (for production)\n   \n   Example .env.production:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=https://your-production-project.supabase.co\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-production-anon-key\n   OPENAI_API_KEY=your-production-openai-key\n   ```\n\n3. Create a Vercel configuration file vercel.json:\n   ```json\n   {\n     \"buildCommand\": \"npm run build\",\n     \"installCommand\": \"npm install\",\n     \"framework\": \"nextjs\",\n     \"regions\": [\"iad1\"],\n     \"headers\": [\n       {\n         \"source\": \"/(.*)\",\n         \"headers\": [\n           { \"key\": \"X-Content-Type-Options\", \"value\": \"nosniff\" },\n           { \"key\": \"X-Frame-Options\", \"value\": \"DENY\" },\n           { \"key\": \"X-XSS-Protection\", \"value\": \"1; mode=block\" },\n           { \"key\": \"Referrer-Policy\", \"value\": \"strict-origin-when-cross-origin\" },\n           { \"key\": \"Content-Security-Policy\", \"value\": \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: https://*.openai.com; connect-src 'self' https://*.supabase.co https://*.openai.com; font-src 'self'; object-src 'none'; media-src 'self'; frame-src 'none';\" }\n         ]\n       }\n     ]\n   }\n   ```\n\n4. Create a GitHub Actions workflow file .github/workflows/deploy.yml:\n   ```yaml\n   name: Deploy\n   \n   on:\n     push:\n       branches: [main]\n   \n   jobs:\n     deploy:\n       runs-on: ubuntu-latest\n       steps:\n         - uses: actions/checkout@v3\n         \n         - name: Setup Node.js\n           uses: actions/setup-node@v3\n           with:\n             node-version: '18'\n             cache: 'npm'\n             \n         - name: Install dependencies\n           run: npm ci\n           \n         - name: Run linting\n           run: npm run lint\n           \n         - name: Run type checking\n           run: npm run typecheck\n           \n         - name: Deploy to Vercel\n           uses: amondnet/vercel-action@v20\n           with:\n             vercel-token: ${{ secrets.VERCEL_TOKEN }}\n             vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}\n             vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\n             vercel-args: '--prod'\n   ```\n\n5. Add scripts to package.json for deployment:\n   ```json\n   \"scripts\": {\n     \"dev\": \"next dev\",\n     \"build\": \"next build\",\n     \"start\": \"next start\",\n     \"lint\": \"next lint\",\n     \"typecheck\": \"tsc --noEmit\",\n     \"db:push\": \"supabase db push\",\n     \"db:reset\": \"supabase db reset\",\n     \"db:migration:new\": \"supabase migration new\",\n     \"deploy\": \"vercel --prod\"\n   }\n   ```\n\n6. Create a README.md with deployment instructions:\n   ```markdown\n   # GPT-Powered Chatbot with Image Generation\n   \n   ## Deployment Guide\n   \n   ### Prerequisites\n   - Supabase account and project\n   - OpenAI API key\n   - Vercel account\n   - GitHub account\n   \n   ### Setup Steps\n   \n   1. **Set up Supabase**\n      - Create a new Supabase project\n      - Run the migrations: `npm run db:push`\n   \n   2. **Configure environment variables**\n      - In Vercel, add the following environment variables:\n        - `NEXT_PUBLIC_SUPABASE_URL`\n        - `NEXT_PUBLIC_SUPABASE_ANON_KEY`\n        - `OPENAI_API_KEY`\n   \n   3. **Deploy to Vercel**\n      - Connect your GitHub repository to Vercel\n      - Configure the build settings\n      - Deploy the application\n   \n   4. **Set up GitHub Actions**\n      - Add the following secrets to your GitHub repository:\n        - `VERCEL_TOKEN`\n        - `VERCEL_ORG_ID`\n        - `VERCEL_PROJECT_ID`\n   \n   ## Development Guide\n   \n   1. Clone the repository\n   2. Install dependencies: `npm install`\n   3. Set up local environment variables in `.env.local`\n   4. Start Supabase locally: `supabase start`\n   5. Run the development server: `npm run dev`\n   ```",
        "testStrategy": "1. Test deployment to staging environment\n2. Verify environment variables are correctly loaded\n3. Test database migrations in production environment\n4. Verify security headers are applied\n5. Test CI/CD pipeline with sample commits\n6. Verify production build optimization\n7. Test rollback procedures",
        "priority": "low",
        "dependencies": [
          2,
          4,
          5,
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-17T13:32:35.941Z",
      "updated": "2025-08-17T17:17:48.711Z",
      "description": "Tasks for master context"
    }
  }
}